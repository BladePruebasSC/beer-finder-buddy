import { useState, useRef, useEffect, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { X, Send, MessageCircle, Bot, User, TrendingUp } from "lucide-react";
import { useNavigate, useLocation } from "react-router-dom";
import { BeerAILoader } from "@/components/BeerAILoader";
import { updateFilterStats, getFilterStats } from "@/lib/filterStats";

// Sistema de tracking de respuestas m√°s utilizadas
const ANSWER_STATS_KEY = 'beer-ai-answer-stats';

interface AnswerStats {
  [answer: string]: number;
}

const getAnswerStats = (): AnswerStats => {
  try {
    const stored = localStorage.getItem(ANSWER_STATS_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
};

const updateAnswerStats = (answer: string) => {
  const stats = getAnswerStats();
  stats[answer] = (stats[answer] || 0) + 1;
  localStorage.setItem(ANSWER_STATS_KEY, JSON.stringify(stats));
};

// Funciones de validaci√≥n para categor√≠as
const isCountry = (value: string): boolean => {
  const countries = [
    'chile', 'm√©xico', 'estados unidos', 'rep√∫blica dominicana', 'alemania', 
    'b√©lgica', 'reino unido', 'espa√±a', 'irlanda', 'rep√∫blica checa', 
    'jap√≥n', 'brasil', 'argentina', 'colombia', 'pa√≠ses bajos'
  ];
  return countries.some(country => value.toLowerCase().includes(country));
};

const isBeerStyle = (value: string): boolean => {
  const styles = [
    'ipa', 'stout', 'lager', 'amber', 'wheat', 'hazy', 'porter', 
    'red ale', 'pilsner', 'pale ale', 'sour', 'belgian', 'blonde'
  ];
  return styles.some(style => value.toLowerCase().includes(style));
};

const isFlavor = (value: string): boolean => {
  const flavors = [
    'c√≠trico', 'tropical', 'amargo', 'chocolate', 'caf√©', 'caramelo', 
    'malta', 'frutal', 'especiado', 'tostado', 'suave', 'refrescante'
  ];
  return flavors.some(flavor => value.toLowerCase().includes(flavor));
};

const isIntensity = (value: string): boolean => {
  const intensities = ['ligera', 'media', 'fuerte', 'light', 'medium', 'strong'];
  return intensities.some(intensity => value.toLowerCase().includes(intensity));
};

const isColor = (value: string): boolean => {
  const colors = [
    'rubia', 'dorado', '√°mbar', 'rojo', 'marr√≥n', 'negro', 'turbio', 
    'verde', 'clara', 'p√∫rpura', 'blanca'
  ];
  return colors.some(color => value.toLowerCase().includes(color));
};

const isBitterness = (value: string): boolean => {
  const bitterness = ['bajo', 'alto', 'low', 'high'];
  return bitterness.some(bitter => value.toLowerCase().includes(bitter));
};

// Funci√≥n para agregar nuevos filtros din√°micamente a las opciones disponibles
const addDynamicFilter = (category: keyof typeof allAnswersPool, newFilter: string, emoji: string = 'üåü') => {
  // Crear una entrada temporal para el nuevo filtro
  const newAnswer = `${emoji} ${newFilter}`;
  
  // Agregar a las estad√≠sticas si no existe
  updateFilterStats(newFilter);
  
  // Retornar la nueva opci√≥n para mostrarla inmediatamente
  return newAnswer;
};

const sortAnswersByPopularity = (answers: string[], category: string, filterStats: Record<string, number>): string[] => {
  
  console.log('üîç sortAnswersByPopularity - category:', category);
  console.log('üîç sortAnswersByPopularity - answers:', answers);
  console.log('üîç sortAnswersByPopularity - filterStats:', filterStats);
  
  return [...answers].sort((a, b) => {
    // Extraer el valor del filtro de la respuesta (despu√©s del emoji)
    const extractFilter = (answer: string) => {
      // Para pa√≠ses, estilos, sabores e intensidad, extraer el texto despu√©s del emoji
      const parts = answer.split(' ').slice(1).join(' ');
      return parts;
    };
    
    const filterA = extractFilter(a);
    const filterB = extractFilter(b);
    
    // Para opciones iniciales, buscar estad√≠sticas de las acciones correspondientes
    let countA = 0;
    let countB = 0;
    
    if (category === 'initial') {
      // Mapear opciones iniciales a sus categor√≠as correspondientes para buscar estad√≠sticas
      if (filterA.includes('pa√≠s') || filterA.includes('origen')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('Rep√∫blica Dominicana') || key.includes('Estados Unidos') || 
          key.includes('M√©xico') || key.includes('Alemania') || key.includes('B√©lgica') ||
          key.includes('Reino Unido') || key.includes('Espa√±a') || key.includes('Irlanda') ||
          key.includes('Rep√∫blica Checa') || key.includes('Jap√≥n') || key.includes('Brasil') ||
          key.includes('Argentina') || key.includes('Chile')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterA.includes('estilo')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('IPA') || key.includes('Stout') || key.includes('Lager') ||
          key.includes('Amber') || key.includes('Wheat') || key.includes('Hazy') ||
          key.includes('Porter') || key.includes('Red Ale') || key.includes('Pilsner') ||
          key.includes('Pale Ale') || key.includes('Sour') || key.includes('Belgian')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterA.includes('sabor')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('C√≠trico') || key.includes('Tropical') || key.includes('Chocolate') ||
          key.includes('Caf√©') || key.includes('Caramelo') || key.includes('Frutal') ||
          key.includes('Nuez') || key.includes('Herbal') || key.includes('Pan tostado') ||
          key.includes('Durazno') || key.includes('Frutos rojos') || key.includes('Naranja')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterA.includes('intensidad')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('Ligera') || key.includes('Media') || key.includes('Fuerte')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterA.includes('color')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('Rubia') || key.includes('√Åmbar') || key.includes('Marr√≥n') ||
          key.includes('Negra') || key.includes('Roja') || key.includes('Verde') ||
          key.includes('Clara') || key.includes('P√∫rpura')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterA.includes('amargo') || filterA.includes('amargor')) {
        countA = Object.keys(filterStats).filter(key => 
          key.includes('Suave') || key.includes('Moderado') || key.includes('Amargo')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      }
      
      // Hacer lo mismo para filterB
      if (filterB.includes('pa√≠s') || filterB.includes('origen')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('Rep√∫blica Dominicana') || key.includes('Estados Unidos') || 
          key.includes('M√©xico') || key.includes('Alemania') || key.includes('B√©lgica') ||
          key.includes('Reino Unido') || key.includes('Espa√±a') || key.includes('Irlanda') ||
          key.includes('Rep√∫blica Checa') || key.includes('Jap√≥n') || key.includes('Brasil') ||
          key.includes('Argentina') || key.includes('Chile')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterB.includes('estilo')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('IPA') || key.includes('Stout') || key.includes('Lager') ||
          key.includes('Amber') || key.includes('Wheat') || key.includes('Hazy') ||
          key.includes('Porter') || key.includes('Red Ale') || key.includes('Pilsner') ||
          key.includes('Pale Ale') || key.includes('Sour') || key.includes('Belgian')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterB.includes('sabor')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('C√≠trico') || key.includes('Tropical') || key.includes('Chocolate') ||
          key.includes('Caf√©') || key.includes('Caramelo') || key.includes('Frutal') ||
          key.includes('Nuez') || key.includes('Herbal') || key.includes('Pan tostado') ||
          key.includes('Durazno') || key.includes('Frutos rojos') || key.includes('Naranja')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterB.includes('intensidad')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('Ligera') || key.includes('Media') || key.includes('Fuerte')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterB.includes('color')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('Rubia') || key.includes('√Åmbar') || key.includes('Marr√≥n') ||
          key.includes('Negra') || key.includes('Roja') || key.includes('Verde') ||
          key.includes('Clara') || key.includes('P√∫rpura')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      } else if (filterB.includes('amargo') || filterB.includes('amargor')) {
        countB = Object.keys(filterStats).filter(key => 
          key.includes('Suave') || key.includes('Moderado') || key.includes('Amargo')
        ).reduce((sum, key) => sum + (filterStats[key] || 0), 0);
      }
    } else {
      // Para otras categor√≠as, usar el m√©todo original
      countA = filterStats[filterA] || 0;
      countB = filterStats[filterB] || 0;
    }
    
    return countB - countA; // Orden descendente (m√°s usadas primero)
  });
};

interface Message {
  id: string;
  type: 'ai' | 'user';
  content: string;
  timestamp: Date;
}

interface AIChatProps {
  isOpen: boolean;
  onClose: () => void;
  onSearch: (filters: any) => void;
  onStartSearch?: () => void;
}

// Definir TODAS las opciones posibles (m√°s que las que se muestran)
const allAnswersPool = {
  initial: [
    "üåç Buscar por pa√≠s de origen",
    "üç∫ Recomendarme por estilo",
    "üçã Buscar por sabor espec√≠fico",
    "üé® Buscar por color",
    "üí™ Encontrar por intensidad",
    "üò§ Buscar por nivel de amargor",
    "üéØ B√∫squeda completa personalizada"
  ],
  
  country: [
    "üá©üá¥ Rep√∫blica Dominicana",
    "üá∫üá∏ Estados Unidos", 
    "üá≤üáΩ M√©xico",
    "üá©üá™ Alemania",
    "üáßüá™ B√©lgica",
    "üá¨üáß Reino Unido",
    "üá™üá∏ Espa√±a",
    "üáÆüá™ Irlanda",
    "üá®üáø Rep√∫blica Checa",
    "üáØüáµ Jap√≥n",
    "üáßüá∑ Brasil",
    "üá¶üá∑ Argentina"
  ],

  style: [
    "üç∫ IPA",
    "‚ö´ Stout",
    "‚ú® Lager",
    "üü† Amber Ale",
    "üåæ Wheat Beer",
    "‚òÅÔ∏è Hazy IPA",
    "üçÇ Porter",
    "üî¥ Red Ale",
    "üåü Pilsner",
    "üíõ Pale Ale",
    "üé® Sour Ale",
    "üçØ Belgian Ale"
  ],

  flavor: [
    "üçã C√≠trico",
    "ü•• Tropical",
    "üåø Amargo",
    "üç´ Chocolate",
    "‚òï Caf√©",
    "üçØ Caramelo",
    "üåæ Malta",
    "üçì Frutal",
    "üå∂Ô∏è Especiado",
    "üî• Tostado",
    "üí´ Suave",
    "‚ùÑÔ∏è Refrescante"
  ],

  intensity: [
    "ü™∂ Ligera (< 5% ABV)",
    "‚öñÔ∏è Media (5-6.5% ABV)",
    "üí™ Fuerte (> 6.5% ABV)"
  ],

  color: [
    "üü° Rubia",
    "üü† √Åmbar",
    "üü§ Marr√≥n",
    "‚ö´ Negra",
    "üî¥ Roja",
    "üü¢ Verde",
    "‚ö™ Clara",
    "üü£ P√∫rpura"
  ],

  bitterness: [
    "üòä Bajo (< 30 IBU)",
    "üò§ Alto (> 50 IBU)"
  ]
};

// Obtener respuestas din√°micas que incluyen todas las opciones disponibles
const getDynamicAnswers = (category: keyof typeof allAnswersPool, filterStats: Record<string, number>): string[] => {
  const allOptions = allAnswersPool[category];
  
  // Para la categor√≠a 'initial', mostrar las opciones predefinidas ordenadas por popularidad
  if (category === 'initial') {
    const sortedOptions = sortAnswersByPopularity(allOptions, category, filterStats);
    console.log('üîç getDynamicAnswers - allOptions:', allOptions);
    console.log('üîç getDynamicAnswers - sortedOptions:', sortedOptions);
    return sortedOptions;
  }
  
  // Crear opciones expandidas que incluyen filtros personalizados usados anteriormente
  const expandedOptions = [...allOptions];
  
  // Agregar filtros personalizados que se hayan usado antes pero no est√©n en las opciones predefinidas
  // Solo agregar filtros que correspondan a la categor√≠a actual
  Object.keys(filterStats).forEach(filterValue => {
    // Verificar si ya existe en las opciones predefinidas (comparando solo el texto, no el emoji)
    const isInPredefined = allOptions.some(option => {
      const optionText = option.split(' ').slice(1).join(' ');
      return optionText.toLowerCase() === filterValue.toLowerCase();
    });
    
    // Verificar si el filtro corresponde a la categor√≠a actual
    let belongsToCategory = false;
    
    if (category === 'country') {
      // Solo pa√≠ses/pa√≠ses
      belongsToCategory = isCountry(filterValue);
    } else if (category === 'style') {
      // Solo estilos de cerveza
      belongsToCategory = isBeerStyle(filterValue);
    } else if (category === 'flavor') {
      // Solo sabores
      belongsToCategory = isFlavor(filterValue);
    } else if (category === 'intensity') {
      // Solo intensidades
      belongsToCategory = isIntensity(filterValue);
    } else if (category === 'color') {
      // Solo colores
      belongsToCategory = isColor(filterValue);
    } else if (category === 'bitterness') {
      // Solo niveles de amargor
      belongsToCategory = isBitterness(filterValue);
    }
    
    if (!isInPredefined && filterStats[filterValue] > 0 && belongsToCategory) {
      // Determinar emoji basado en la categor√≠a y el valor espec√≠fico
      let emoji = 'üåü';
      
      if (category === 'country') {
        // Mapear pa√≠ses espec√≠ficos a sus banderas
        const countryFlags: { [key: string]: string } = {
          'chile': 'üá®üá±',
          'm√©xico': 'üá≤üáΩ',
          'estados unidos': 'üá∫üá∏',
          'rep√∫blica dominicana': 'üá©üá¥',
          'alemania': 'üá©üá™',
          'b√©lgica': 'üáßüá™',
          'reino unido': 'üá¨üáß',
          'espa√±a': 'üá™üá∏',
          'irlanda': 'üáÆüá™',
          'rep√∫blica checa': 'üá®üáø',
          'jap√≥n': 'üáØüáµ',
          'brasil': 'üáßüá∑',
          'argentina': 'üá¶üá∑',
          'colombia': 'üá®üá¥',
          'pa√≠ses bajos': 'üá≥üá±'
        };
        emoji = countryFlags[filterValue.toLowerCase()] || 'üåç';
      } else if (category === 'style') {
        emoji = 'üç∫';
      } else if (category === 'flavor') {
        emoji = 'üçã';
      } else if (category === 'intensity') {
        emoji = 'üí™';
      } else if (category === 'color') {
        emoji = 'üé®';
      } else if (category === 'bitterness') {
        emoji = 'üî•';
      }
      
      expandedOptions.push(`${emoji} ${filterValue}`);
    }
  });
  
  const sorted = sortAnswersByPopularity(expandedOptions, category, filterStats);
  
  // Para categor√≠as con m√°s de 6 opciones, mostrar las m√°s populares + algunas aleatorias de las menos usadas
  if (expandedOptions.length > 6) {
    const popular = sorted.slice(0, 4); // Las 4 m√°s populares siempre
    const lessPopular = sorted.slice(4); // El resto
    const randomLessPopular = lessPopular
      .sort(() => Math.random() - 0.5) // Mezclar aleatoriamente
      .slice(0, 2); // Tomar 2 aleatorias
    return [...popular, ...randomLessPopular];
  }
  
  // Para categor√≠as con 6 o menos opciones, mostrar todas
  return sorted;
};

const getConversationSteps = (filterStats: Record<string, number>) => ({
  initial: {
    question: "¬°Hola! ¬øCon qu√© puedo ayudarte?",
    get answers() {
      return getDynamicAnswers('initial', filterStats);
    }
  },
  
  country: {
    question: "¬°Perfecto! ¬øDe qu√© pa√≠s te gustar√≠a probar cervezas?",
    get answers() {
      return getDynamicAnswers('country', filterStats);
    }
  },

  style: {
    question: "¬°Excelente! ¬øQu√© estilo de cerveza prefieres?",
    get answers() {
      return getDynamicAnswers('style', filterStats);
    }
  },

  flavor: {
    question: "¬°Me encanta! ¬øQu√© sabor espec√≠fico buscas?",
    get answers() {
      return getDynamicAnswers('flavor', filterStats);
    }
  },

  color: {
    question: "¬°Genial! ¬øQu√© color de cerveza prefieres?",
    get answers() {
      return getDynamicAnswers('color', filterStats);
    }
  },

  intensity: {
    question: "¬°Perfecto! ¬øQu√© intensidad prefieres?",
    get answers() {
      return getDynamicAnswers('intensity', filterStats);
    }
  },

  bitterness: {
    question: "¬°Excelente! ¬øQu√© nivel de amargor prefieres?",
    get answers() {
      return getDynamicAnswers('bitterness', filterStats);
    }
  }
});

export const AIChat = ({ isOpen, onClose, onSearch, onStartSearch }: AIChatProps) => {
  const location = useLocation();
  const [filterStats, setFilterStats] = useState<Record<string, number>>({});
  
  // Crear conversationSteps con las estad√≠sticas actuales
  const conversationSteps = useMemo(() => getConversationSteps(filterStats), [filterStats]);
  
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      type: 'ai',
      content: getConversationSteps({}).initial.question,
      timestamp: new Date()
    }
  ]);
  const [currentStep, setCurrentStep] = useState<'initial' | 'country' | 'style' | 'flavor' | 'color' | 'intensity' | 'bitterness'>('initial');
  const [selectedFilters, setSelectedFilters] = useState<any>({
    style: [],
    color: [],
    flavor: [],
    strength: [],
    bitterness: [],
    origin: []
  });
  const [showAnswers, setShowAnswers] = useState(false);
  const [answerKey, setAnswerKey] = useState(0);
  const [isTyping, setIsTyping] = useState(false);
  const [showSearchLoader, setShowSearchLoader] = useState(false);
  const [lastActivityTime, setLastActivityTime] = useState<number>(Date.now());
  const [refreshAnswers, setRefreshAnswers] = useState(0);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inactivityTimerRef = useRef<NodeJS.Timeout | null>(null);
  const navigate = useNavigate();

  // Cargar estad√≠sticas de filtros al abrir el chat
  useEffect(() => {
    if (isOpen) {
      getFilterStats().then(stats => {
        setFilterStats(stats);
      }).catch(error => {
        console.error('Error loading filter stats:', error);
      });
    }
  }, [isOpen, refreshAnswers]);

  const scrollToCenter = () => {
    const chatContainer = document.querySelector('.chat-messages-container');
    if (chatContainer) {
      // Calcular la posici√≥n central del contenido
      const containerHeight = chatContainer.clientHeight;
      const scrollHeight = chatContainer.scrollHeight;
      const centerPosition = (scrollHeight - containerHeight) / 2;
      
      chatContainer.scrollTo({
        top: Math.max(0, centerPosition),
        behavior: 'smooth'
      });
    }
  };

  const resetChat = () => {
    setMessages([
      {
        id: '1',
        type: 'ai',
        content: conversationSteps.initial.question,
        timestamp: new Date()
      }
    ]);
    setCurrentStep('initial');
    setSelectedFilters({
      style: [],
      color: [],
      flavor: [],
      strength: [],
      bitterness: [],
      origin: []
    });
    setShowAnswers(false);
    setAnswerKey(prev => prev + 1);
    setRefreshAnswers(prev => prev + 1); // Forzar actualizaci√≥n de respuestas din√°micas
    setIsTyping(false);
    setLastActivityTime(Date.now());
  };

  const updateActivity = () => {
    setLastActivityTime(Date.now());
  };

  useEffect(() => {
    if (messages.length > 1) {
      setTimeout(() => {
        scrollToCenter();
      }, 300);
    }
  }, [messages]);

  // Scroll cuando se muestran las respuestas
  useEffect(() => {
    if (showAnswers) {
      const timer = setTimeout(() => {
        scrollToCenter();
      }, 400); // Esperar a que termine la animaci√≥n de cascada
      return () => clearTimeout(timer);
    }
  }, [showAnswers]);

  // Mostrar respuestas iniciales al abrir el chat y centrar contenido
  useEffect(() => {
    if (isOpen && currentStep === 'initial') {
      const timer = setTimeout(() => {
        setShowAnswers(true);
        scrollToCenter(); // Centrar el contenido inicial
      }, 600);
      return () => clearTimeout(timer);
    }
  }, [isOpen, currentStep]);

  // Reiniciar chat despu√©s de 15 segundos de inactividad
  useEffect(() => {
    if (!isOpen) return;

    // Limpiar timer anterior si existe
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }

    // Crear nuevo timer
    inactivityTimerRef.current = setTimeout(() => {
      const timeSinceLastActivity = Date.now() - lastActivityTime;
      if (timeSinceLastActivity >= 15000) {
        // 15 segundos de inactividad
        resetChat();
        // Mostrar respuestas iniciales despu√©s del reset
        setTimeout(() => {
          setShowAnswers(true);
        }, 600);
      }
    }, 15000);

    // Cleanup al desmontar o cuando cambie la dependencia
    return () => {
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
    };
  }, [isOpen, lastActivityTime]);


  // Prevenir scroll del body cuando el chat est√° abierto
  useEffect(() => {
    if (isOpen) {
      // Guardar la posici√≥n actual del scroll
      const scrollY = window.scrollY;
      // Prevenir scroll del body
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollY}px`;
      document.body.style.width = '100%';
    } else {
      // Restaurar el scroll del body
      const scrollY = document.body.style.top;
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || '0') * -1);
      }
    }

    // Cleanup
    return () => {
      if (isOpen) {
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
      }
    };
  }, [isOpen]);

  // Reiniciar conversaci√≥n cuando se abre el chat (solo cuando cambia de cerrado a abierto)
  const prevIsOpenRef = useRef(isOpen);
  
  useEffect(() => {
    // Solo resetear cuando el chat se acaba de abrir (transici√≥n de false a true)
    if (isOpen && !prevIsOpenRef.current) {
      // Usar setTimeout para evitar actualizaci√≥n durante render
      setTimeout(() => {
        resetChat();
      }, 0);
    }
    prevIsOpenRef.current = isOpen;
  }, [isOpen]);

  const addMessage = (type: 'ai' | 'user', content: string) => {
    const newMessage: Message = {
      id: Date.now().toString(),
      type,
      content,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, newMessage]);
  };

  const addTypingMessage = (content: string, callback?: () => void) => {
    setIsTyping(true);
    
    // Simular tiempo de escritura m√°s r√°pido
    const typingDuration = Math.min(content.length * 15, 1200); // 15ms por car√°cter, m√°ximo 1.2s
    
    setTimeout(() => {
      // Crear el mensaje completo cuando termine de "escribir"
      const newMessage: Message = {
        id: Date.now().toString(),
        type: 'ai',
        content,
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, newMessage]);
      setIsTyping(false);
      
      if (callback) {
        setTimeout(callback, 300); // Reducido de 500ms a 300ms
      }
    }, typingDuration);
  };

  const handlePredefinedAnswer = (answer: string) => {
    // Actualizar actividad
    updateActivity();
    
    // Ocultar respuestas inmediatamente
    setShowAnswers(false);
    
    // Primero mostrar la respuesta del usuario
    addMessage('user', answer);

    // Esperar un poco para que se vea la respuesta del usuario
    setTimeout(() => {
      // Procesar la respuesta seg√∫n el paso actual
      let updatedFilters = { ...selectedFilters };
      let nextStep = currentStep;

      if (currentStep === 'initial') {
        // Determinar el siguiente paso basado en la respuesta
        if (answer.includes('pa√≠s') || answer.includes('origen')) {
          nextStep = 'country';
        } else if (answer.includes('estilo')) {
          nextStep = 'style';
        } else if (answer.includes('sabor')) {
          nextStep = 'flavor';
        } else if (answer.includes('color')) {
          nextStep = 'color';
        } else if (answer.includes('intensidad')) {
          nextStep = 'intensity';
        } else if (answer.includes('amargo') || answer.includes('amargor') || answer.includes('nivel de amargor')) {
          nextStep = 'bitterness';
        } else if (answer.includes('completa')) {
          // B√∫squeda completa - empezar con el primer paso
          nextStep = 'country';
        }
      } else {
        // Procesar la selecci√≥n espec√≠fica y registrar el filtro usado
        if (currentStep === 'country') {
          // Extraer el pa√≠s correctamente del emoji + texto
          let selectedCountry = "";
          if (answer.includes("Rep√∫blica Dominicana")) { selectedCountry = "Rep√∫blica Dominicana"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Estados Unidos")) { selectedCountry = "Estados Unidos"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("M√©xico")) { selectedCountry = "M√©xico"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Alemania")) { selectedCountry = "Alemania"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("B√©lgica")) { selectedCountry = "B√©lgica"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Reino Unido")) { selectedCountry = "Reino Unido"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Espa√±a")) { selectedCountry = "Espa√±a"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Irlanda")) { selectedCountry = "Irlanda"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Rep√∫blica Checa")) { selectedCountry = "Rep√∫blica Checa"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Jap√≥n")) { selectedCountry = "Jap√≥n"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Brasil")) { selectedCountry = "Brasil"; updatedFilters.origin = [selectedCountry]; }
          else if (answer.includes("Argentina")) { selectedCountry = "Argentina"; updatedFilters.origin = [selectedCountry]; }
          
          console.log('üîç Pa√≠s seleccionado:', selectedCountry);
          console.log('üîç updatedFilters despu√©s de pa√≠s:', updatedFilters);
          if (selectedCountry) updateFilterStats(selectedCountry);
        } else if (currentStep === 'style') {
          // Extraer el estilo correctamente
          let selectedStyle = "";
          if (answer.includes("IPA") && !answer.includes("Hazy")) { selectedStyle = "IPA"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Stout")) { selectedStyle = "Stout"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Lager")) { selectedStyle = "Lager"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Amber")) { selectedStyle = "Amber Ale"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Wheat")) { selectedStyle = "Wheat Beer"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Hazy")) { selectedStyle = "Hazy IPA"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Porter")) { selectedStyle = "Porter"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Red Ale")) { selectedStyle = "Red Ale"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Pilsner")) { selectedStyle = "Pilsner"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Pale Ale")) { selectedStyle = "Pale Ale"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Sour")) { selectedStyle = "Sour Ale"; updatedFilters.style = [selectedStyle]; }
          else if (answer.includes("Belgian")) { selectedStyle = "Belgian Ale"; updatedFilters.style = [selectedStyle]; }
          
          if (selectedStyle) updateFilterStats(selectedStyle);
        } else if (currentStep === 'flavor') {
          // Extraer el sabor correctamente
          let selectedFlavor = "";
          if (answer.includes("C√≠trico")) { selectedFlavor = "C√≠trico"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Tropical")) { selectedFlavor = "Tropical"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Chocolate")) { selectedFlavor = "Chocolate"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Caf√©")) { selectedFlavor = "Caf√©"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Caramelo")) { selectedFlavor = "Caramelo"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Frutal")) { selectedFlavor = "Frutal"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Nuez")) { selectedFlavor = "Nuez"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Herbal")) { selectedFlavor = "Herbal"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Pan tostado")) { selectedFlavor = "Pan tostado"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Durazno")) { selectedFlavor = "Durazno"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Frutos rojos")) { selectedFlavor = "Frutos rojos"; updatedFilters.flavor = [selectedFlavor]; }
          else if (answer.includes("Naranja")) { selectedFlavor = "Naranja"; updatedFilters.flavor = [selectedFlavor]; }
          
          if (selectedFlavor) updateFilterStats(selectedFlavor);
        } else if (currentStep === 'intensity') {
          let selectedIntensity = "";
          if (answer.includes("Ligera")) { selectedIntensity = "Ligera"; updatedFilters.strength = ["light"]; }
          else if (answer.includes("Media")) { selectedIntensity = "Media"; updatedFilters.strength = ["medium"]; }
          else if (answer.includes("Fuerte")) { selectedIntensity = "Fuerte"; updatedFilters.strength = ["strong"]; }
          
          if (selectedIntensity) updateFilterStats(selectedIntensity);
        } else if (currentStep === 'color') {
          let selectedColor = "";
          if (answer.includes("Rubia")) { selectedColor = "Rubia"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("√Åmbar")) { selectedColor = "√Åmbar"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("Marr√≥n")) { selectedColor = "Marr√≥n"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("Negra")) { selectedColor = "Negra"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("Roja")) { selectedColor = "Roja"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("Verde")) { selectedColor = "Verde"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("Clara")) { selectedColor = "Clara"; updatedFilters.color = [selectedColor]; }
          else if (answer.includes("P√∫rpura")) { selectedColor = "P√∫rpura"; updatedFilters.color = [selectedColor]; }
          
          if (selectedColor) updateFilterStats(selectedColor);
        } else if (currentStep === 'bitterness') {
          let selectedBitterness = "";
          if (answer.includes("Suave")) { selectedBitterness = "Suave"; updatedFilters.bitterness = ["low"]; }
          else if (answer.includes("Moderado")) { selectedBitterness = "Moderado"; updatedFilters.bitterness = ["medium"]; }
          else if (answer.includes("Amargo")) { selectedBitterness = "Amargo"; updatedFilters.bitterness = ["high"]; }
          
          if (selectedBitterness) updateFilterStats(selectedBitterness);
        }

        // Determinar si continuar con la b√∫squeda completa o finalizar
        const isCompleteSearch = location.state?.from === 'complete-search' || 
                                messages.some(msg => msg.content.includes('completa'));
        
        if (isCompleteSearch) {
          // B√∫squeda completa - determinar el siguiente paso
          if (currentStep === 'country') {
            nextStep = 'style';
          } else if (currentStep === 'style') {
            nextStep = 'flavor';
          } else if (currentStep === 'flavor') {
            nextStep = 'color';
          } else if (currentStep === 'color') {
            nextStep = 'intensity';
          } else if (currentStep === 'intensity') {
            nextStep = 'bitterness';
          } else if (currentStep === 'bitterness') {
            // Finalizar la b√∫squeda completa
            setTimeout(() => {
              addTypingMessage('¬°Perfecto! Bas√°ndome en todas tus preferencias, voy a buscar las cervezas ideales para ti üéØ', () => {
                setTimeout(() => {
                  console.log('üîç Filtros desde chat:', updatedFilters); // Debug
                  setRefreshAnswers(prev => prev + 1); // Actualizar respuestas din√°micas
                  onStartSearch?.(); // Iniciar b√∫squeda en el componente padre
                  onSearch(updatedFilters); // Pasar los filtros
                }, 500);
              });
            }, 800);
            return;
          }
        } else {
          // B√∫squeda normal - finalizar despu√©s de cualquier selecci√≥n espec√≠fica
          console.log('üîç B√∫squeda normal - updatedFilters antes de enviar:', updatedFilters);
        setTimeout(() => {
          addTypingMessage('¬°Perfecto! Bas√°ndome en tus preferencias, voy a buscar las cervezas ideales para ti üéØ', () => {
            setTimeout(() => {
              console.log('üîç Filtros desde chat:', updatedFilters); // Debug
                setRefreshAnswers(prev => prev + 1); // Actualizar respuestas din√°micas
              onStartSearch?.(); // Iniciar b√∫squeda en el componente padre
              onSearch(updatedFilters); // Pasar los filtros
            }, 500);
          });
          }, 800);
        return;
        }
      }

      setSelectedFilters(updatedFilters);
      setCurrentStep(nextStep);

        // Mostrar siguiente pregunta con animaci√≥n de escritura
        setTimeout(() => {
          const nextQuestion = conversationSteps[nextStep].question;
          addTypingMessage(nextQuestion, () => {
            // Mostrar nuevas respuestas despu√©s de que termine de escribir
            setShowAnswers(true);
            setAnswerKey(prev => prev + 1); // Forzar re-render para nueva animaci√≥n
            setRefreshAnswers(prev => prev + 1); // Actualizar respuestas din√°micas
          });
        }, 800); // Reducido de 1500ms a 800ms
    }, 500); // Reducido de 800ms a 500ms
  };

  const handleSearchComplete = () => {
    // Obtener los filtros actuales
    const currentFilters = currentStep === 'country' || currentStep === 'style' || 
                          currentStep === 'flavor' || currentStep === 'intensity' ? 
                          selectedFilters : {};
    
    onSearch(currentFilters);
    setShowSearchLoader(false); // Ocultar el loader
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-start justify-center pt-4 sm:pt-8 md:items-center md:pt-0 p-2 sm:p-4 animate-in fade-in duration-300" style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0 }}>
      <Card className="w-full max-w-md h-[75vh] sm:h-[85vh] md:h-[650px] max-h-[600px] sm:max-h-[700px] flex flex-col bg-gradient-to-b from-card to-card/95 border-border shadow-2xl animate-in slide-in-from-bottom-4 duration-500">
        {/* Header */}
        <div className="flex items-center justify-between p-4 sm:p-6 border-b border-border/50 bg-gradient-to-r from-primary/5 to-accent/5">
          <div className="flex items-center gap-2 sm:gap-3">
            <div className="w-8 h-8 sm:w-10 sm:h-10 bg-gradient-to-br from-primary to-accent rounded-full flex items-center justify-center shadow-lg animate-pulse">
              <Bot className="text-white" size={16} />
            </div>
            <div>
              <h3 className="font-bold text-base sm:text-lg bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">
                Beer AI
              </h3>
              <p className="text-xs text-muted-foreground">Tu sommelier personal</p>
            </div>
          </div>
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={onClose}
            className="w-8 h-8 sm:w-10 sm:h-10 hover:bg-destructive/10 hover:text-destructive transition-colors duration-200"
          >
            <X size={16} />
          </Button>
        </div>

         {/* Messages */}
         <div className="flex-1 overflow-y-auto p-4 sm:p-6 space-y-4 sm:space-y-6 bg-gradient-to-b from-background/50 to-transparent chat-messages-container">
          {messages.map((message, index) => (
            <div
              key={message.id}
              className={`flex ${message.type === 'user' ? 'justify-end' : 'justify-start'} animate-in fade-in slide-in-from-bottom-2 duration-500`}
              style={{ animationDelay: `${index * 100}ms` }}
            >
              <div
                className={`max-w-[85%] p-3 sm:p-4 rounded-2xl sm:rounded-3xl shadow-lg ${
                  message.type === 'user'
                    ? 'bg-gradient-to-r from-primary to-accent text-primary-foreground ml-2 sm:ml-4'
                    : 'bg-gradient-to-r from-muted to-muted/80 text-foreground mr-2 sm:mr-4 border border-border/50'
                }`}
              >
                <div className="flex items-start gap-2 sm:gap-3">
                  {message.type === 'ai' && (
                    <div className="w-5 h-5 sm:w-6 sm:h-6 bg-gradient-to-br from-primary/20 to-accent/20 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
                      <Bot size={10} className="text-primary sm:hidden" />
                      <Bot size={12} className="text-primary hidden sm:block" />
                    </div>
                  )}
                  {message.type === 'user' && (
                    <div className="w-5 h-5 sm:w-6 sm:h-6 bg-white/20 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
                      <User size={10} className="text-white sm:hidden" />
                      <User size={12} className="text-white hidden sm:block" />
                    </div>
                  )}
                  <p className="text-xs sm:text-sm font-medium leading-relaxed">{message.content}</p>
                </div>
              </div>
            </div>
          ))}

          {/* Predefined Answers */}
          {conversationSteps[currentStep] && showAnswers && (
            <div className="space-y-3 sm:space-y-4" key={`${answerKey}-${refreshAnswers}`}>
              <div className="text-center animate-in fade-in duration-500">
                <div className="inline-flex items-center gap-2 px-3 py-2 sm:px-4 sm:py-2 rounded-full bg-gradient-to-r from-primary/10 to-accent/10 border border-primary/20">
                  <div className="w-2 h-2 bg-primary rounded-full animate-pulse"></div>
                  <p className="text-xs sm:text-sm font-medium text-primary">Selecciona una opci√≥n</p>
                </div>
              </div>
              <div className="grid grid-cols-1 gap-2 sm:gap-3">
                {conversationSteps[currentStep].answers.map((answer, index) => {
                  // Extraer el valor del filtro (texto despu√©s del emoji)
                  const filterValue = answer.split(' ').slice(1).join(' ');
                  
                  // Obtener el contador solo si el valor exacto existe en filterStats
                  // Esto asegura que solo se muestren estad√≠sticas de la categor√≠a correcta
                  let count = 0;
                  
                  // Buscar coincidencia exacta o parcial dependiendo de la categor√≠a
                  if (currentStep === 'country') {
                    // Para pa√≠ses, buscar coincidencia exacta
                    count = filterStats[filterValue] || 0;
                  } else if (currentStep === 'style') {
                    // Para estilos, buscar coincidencia exacta
                    count = filterStats[filterValue] || 0;
                  } else if (currentStep === 'flavor') {
                    // Para sabores, buscar coincidencia exacta
                    count = filterStats[filterValue] || 0;
                  } else if (currentStep === 'intensity') {
                    // Para intensidad, buscar por palabras clave
                    if (filterValue.includes('Ligera')) count = filterStats['Ligera'] || filterStats['light'] || 0;
                    else if (filterValue.includes('Media')) count = filterStats['Media'] || filterStats['medium'] || 0;
                    else if (filterValue.includes('Fuerte')) count = filterStats['Fuerte'] || filterStats['strong'] || 0;
                  } else if (currentStep === 'color') {
                    // Para colores, buscar por palabras clave
                    const colorMatch = filterValue.match(/Rubia|Dorado|√Åmbar|Rojo|Marr√≥n|Negro|Turbio/);
                    if (colorMatch) count = filterStats[colorMatch[0]] || 0;
                  } else if (currentStep === 'bitterness') {
                    // Para amargor, buscar por palabras clave
                    if (filterValue.includes('Suave')) count = filterStats['Suave'] || filterStats['low'] || 0;
                    else if (filterValue.includes('Moderado')) count = filterStats['Moderado'] || filterStats['medium'] || 0;
                    else if (filterValue.includes('Amargo')) count = filterStats['Amargo'] || filterStats['high'] || 0;
                  }
                  
                  return (
                    <Button
                      key={`${answerKey}-${refreshAnswers}-${index}`}
                      variant="outline"
                      size="lg"
                      onClick={() => handlePredefinedAnswer(answer)}
                      className="group justify-start text-left h-auto py-3 px-3 sm:py-4 sm:px-4 rounded-xl sm:rounded-2xl border-2 border-border/50 hover:border-primary/50 hover:bg-gradient-to-r hover:from-primary/5 hover:to-accent/5 transition-all duration-300 hover:scale-[1.02] hover:shadow-lg cascade-animation"
                    >
                      <div className="flex items-center gap-2 sm:gap-3 w-full">
                        <div className="text-base sm:text-lg group-hover:scale-110 transition-transform duration-200">
                          {answer.split(' ')[0]}
                        </div>
                        <span className="font-medium text-xs sm:text-sm group-hover:text-primary transition-colors duration-200 flex-1">
                          {filterValue}
                        </span>
                        {count > 0 && (
                          <Badge variant="secondary" className="text-[9px] sm:text-[10px] px-1.5 py-0.5 sm:px-2 bg-muted">
                            {count}x
                          </Badge>
                        )}
                      </div>
                    </Button>
                  );
                })}
              </div>
            </div>
          )}

          {/* Typing Indicator */}
          {isTyping && (
            <div className="flex justify-start animate-in fade-in slide-in-from-bottom-2 duration-300">
              <div className="max-w-[85%] p-4 rounded-3xl shadow-lg bg-gradient-to-r from-muted to-muted/80 text-foreground mr-4 border border-border/50">
                <div className="flex items-start gap-3">
                  <div className="w-6 h-6 bg-gradient-to-br from-primary/20 to-accent/20 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
                    <Bot size={12} className="text-primary" />
                  </div>
                  <div className="flex items-center gap-1">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                      <div className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                      <div className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

        </div>

        {/* Footer */}
        <div className="p-4 sm:p-6 border-t border-border/50 bg-gradient-to-r from-muted/30 to-muted/10">
          <div className="text-center">
            <div className="flex items-center justify-center gap-2 text-xs text-muted-foreground">
              <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></div>
              <span className="text-xs sm:text-xs">IA activa - Selecciona una opci√≥n para continuar</span>
            </div>
          </div>
        </div>
      </Card>

      {/* Search Loader */}
      {showSearchLoader && (
        <BeerAILoader
          type="search"
          onComplete={handleSearchComplete}
        />
      )}
    </div>
  );
};
